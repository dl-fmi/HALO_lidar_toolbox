function [data1,att1,dim1] = convert2Cloudnet(site,DATE,measmode,typeof,data0)
%convert2Cloudnet converts original Halo measurement data struct into 
%cloudnet naming scheme and if provided, also adds the corrected signal 
%into the data struct together with recalculated radial velocity and 
%attenuated backscatter coefficients.
%
% Usage:
% data1 = convert2Cloudnet(site,DATE,data0)
% [data1,att1,dim1] = convert2Cloudnet(site,DATE,data0)
% [data1,att1,dim1] = convert2Cloudnet(site,DATE,data0,snr_corr)
%
% Inputs:
% - site            string, name of the site, e.g. 'kuopio'
% - DATE            scalar, numerical date, e.g. 20171231
% - measmode        string, 'stare','vad','rhi','co','windvad','winddbs','txt','wstats',
%                   'TKE','sigma2vad','windshear','LLJ','ABLclassification','cloud'
% - typeof          string, 'co','cross','3beams','eleXX','aziXXX'
% - data0           struct, original data struct
% - snr_corr        background corrected SNR
%
% Outputs:
% - data1           struct, converted into cloudnet naming scheme
% - att1            struct, converted into cloudnet naming scheme
% - dim1            struct, converted into cloudnet naming scheme
%
% Created 2017-12-11
% Antti Manninen
% antti.j.manninen(at)helsinki.fi
% University of Helsinki, Finland

% Check inputs
if nargin < 3
    error('''site'', ''DATES'', and data0 are required inputs!')
end
if ~ischar(site)
    error('The first input ''site'' must be a string.')
end
if ~isnumeric(DATE) || length(num2str(DATE))~=8 
    error(['The second input ''DATE'' must be a numerical date in' ...
        ' YYYYMMDD format.'])
end


% Get default and site specific parameters
C = getconfig(site,DATE);
abc = [measmode '_' typeof];

%-- Check format and convert into decimal hours --%
switch C.time_format_original
    case 'julian'
        [~,~,~,hh,mm,sss] = jd2date(...
            data0.(C.field_name_original_time)(:));
        original_timehrs = hh(:)+mm(:)/60+sss(:)/3600;
    case 'hours'
        original_timehrs = data0.(C.field_name_original_time)(:);
    case 'seconds'
        original_timehrs = data0.(C.field_name_original_time)(:)/3600;
end

%% Assign new values, save old data
% elevation
data1.elevation = data0.(C.field_name_original_elevation)(:);
% azimuth
data1.azimuth = data0.(C.field_name_original_azimuth)(:);
data1.azimuth(data1.azimuth<0) = 360+data1.azimuth(data1.azimuth<0);
% altitude
% if specified
if isfield(C,'field_name_original_altitude')
    data1.altitude = data0.(C.field_name_original_altitude);
elseif isfield(C,'altitude_in_meters')
    data1.altitude = C.altitude_in_meters;
else
    error('Altitude for the site %s not specified in the halo config!',site)
end
% latitude
if isfield(C,'field_name_original_latitude')
    data1.latitude = data0.(C.field_name_original_latitude);
elseif isfield(C,'latitude')
    data1.latitude = C.latitude;
else
    error('Latitude for the site %s not specified in the halo config!',site)
end
% longitude
if isfield(C,'field_name_original_longitude')
    data1.longitude = data0.(C.field_name_original_longitude);
elseif isfield(C,'longitude')
    data1.longitude = C.longitude;
else
    error('Longitude for the site %s not specified in the halo config!',site)
end
% noise threshold
data1.noise_threshold = C.(['snr_threshold_for_' abc]);
% bandwidth
data1.bandwidth = C.bandwidth;
% pulse_length
data1.pulse_length = C.pulse_length;
% prf
data1.prf = C.prf;
% wavelength
data1.wavelength = C.wavelength;
% beam energy
data1.beam_energy = C.beam_energy;
% focus
data1.focus = C.(['focus_' abc]);
% divergence
data1.divergence = C.divergence;
% lens diameter
data1.lens_diameter = C.lens_diameter;
% number of samples per gate
data1.num_samples_gate = C.(['num_samples_gate_' abc]);
% number of lags for the autocorrelation
data1.num_lags = C.num_lags;
% number of pulses per ray
data1.num_pulses_m1 = C.(['num_pulses_m1_' abc]);
data1.num_pulses_m2 = C.(['num_pulses_m2_' abc]);
% time
data1.time = original_timehrs(:);
% range
switch C.range_units_original
    case 'm'
        data1.range = data0.(C.field_name_original_range)(:);
    case 'km'
        data1.range = data0.(C.field_name_original_range)(:)/1000;
end
% beta_raw, v_raw, , signal, signal0 according to original dimensions
[lrow,lcol] = size(data0.(C.field_name_original_attenuated_backscatter));
if lrow == length(data0.(C.field_name_original_time))
    if isfield(data0,[C.field_name_original_snr '_' C.corrected_field_name_identifier])
        data1.signal0 = data0.(C.field_name_original_snr);
        data1.signal = data0.([C.field_name_original_snr '_' C.corrected_field_name_identifier]);
    else
        data1.signal = data0.(C.field_name_original_snr);
    end
    data1.beta_raw = data0.(C.field_name_original_attenuated_backscatter);
    data1.v_raw = data0.(C.field_name_original_radial_velocity);
elseif lcol == length(data0.(C.field_name_original_time))
    if isfield(data0,[C.field_name_original_snr '_' C.corrected_field_name_identifier]) 
        data1.signal0 = transpose(data0.(C.field_name_original_snr));
        data1.signal = transpose(data0.([C.field_name_original_snr '_' C.corrected_field_name_identifier]));
    else
        data1.signal = transpose(data0.(C.field_name_original_snr));
    end
    data1.beta_raw = transpose(data0.(C.field_name_original_attenuated_backscatter));
    data1.v_raw = transpose(data0.(C.field_name_original_radial_velocity));
end
% beta_error
data1.beta_error = (1/sqrt(data1.num_pulses_m1)) .* (1+(1./abs(data1.signal-1)));
data1.beta_error0 = (1/sqrt(data1.num_pulses_m1)) .* (1+(1./abs(data1.signal0-1)));
% v_error and attributes, Rye & Hardesty (1993); OConnor et al. (2010)
[data1.v_error,att1.v_error] = calculateHALOveloError(site,DATE,measmode,typeof,data1.signal);
[data1.v_error0,att1.v_error0] = calculateHALOveloError(site,DATE,measmode,typeof,data1.signal0);
% apply snr threshold and generate v and beta
data1.beta = data1.beta_raw;
data1.beta(data1.signal < double(data1.noise_threshold)) = nan;
data1.v = data1.v_raw;
data1.v(data1.signal < double(data1.noise_threshold)) = nan;
% % clean lowest most range bins
% data1.v(:,1:3) = nan;
% data1.v_raw(:,1:3) = nan;
% data1.beta(:,1:3) = nan;
% data1.beta_raw(:,1:3) = nan;
% data1.signal(:,1:3) = nan;
% data1.signal0(:,1:3) = nan;

%% Create attributes
%
att1.v_error0.comments = 'Uncertainty of radial velocity estimated from original signal';
att1.v_error.comments = 'Uncertainty of radial velocity estimated from corrected signal';
% radial velocity (raw)
att1.v_raw = create_attributes(...
    {'time','range'},...
    'Radial velocity (positive away from lidar)', ...
    {'m s-1','m sr<sup>-1</sup>'}, ...
    C.missing_value, ...
    'No noise removal.', ...
    {[-2 2],'linear'});
att1.v_raw.short_name = 'Doppler velocity (raw)';
att1.v_raw.resolution = C.resolution;
% bkg corrected signal
att1.signal = create_attributes(...
    {'time','range'},...
    'Signal (raw)', ...
    'arbitrary units', ...
    C.missing_value, ...
    ['Background corrected signal (SNR + 1)' ...
    ' in arbitrary units.']);
% original signal
att1.signal0 = create_attributes(...
    {'time','range'},...
    'Signal (raw)', ...
    'arbitrary units', ...
    C.missing_value, ...
    ['Original signal (SNR + 1) in arbitrary' ...
    ' units. No range correction or other' ...
    ' corrections applied.']);
% time
att1.time = create_attributes(...
    {'time'},...
    'Decimal hours UTC', ...
    'Hours UTC');
att1.time.axis = 'T';
% range
att1.range = create_attributes(...
    {'range'},...
    'Height above ground', ...
    'm',...
    [],...
    'This variable is range from lidar * sin(elevation)');
att1.range.axis = 'Z';
% latitude
att1.latitude = create_attributes(...
    {},...
    'Latitude of lidar', ...
    'degrees_north');
att1.latitude.standard_name = 'latitude';
% longitude
att1.longitude = create_attributes(...
    {},...
    'Longitude of lidar', ...
    'degrees_east');
att1.longitude.standard_name = 'longitude';
% altitude
att1.altitude = create_attributes(...
    {},...
    'Height of instrument above mean sea level', ...
    'm');
% azimuth
att1.azimuth = create_attributes(...
    {'time'},...
    'Azimuth from North', ...
    'degrees');
% elevation
att1.elevation = create_attributes(...
    {'time'},...
    'Elevation from horizontal', ...
    'degrees');
att1.elevation.standard_name = 'Alevation from the horizon';
% num_pulses_m1
att1.num_pulses_m1 = create_attributes(...
    {},...
    'Number of pulses per ray in mode 1', ...
    'unitless');
att1.elevation.standard_name = 'elevation';
% focus
att1.focus = create_attributes(...
    {},...
    'Focus range', ...
    'm');
% num_samples_gate
att1.num_samples_gate = create_attributes(...
    {},...
    'Number of samples (points) per gate', ...
    'unitless');
% beta_raw
att1.beta_raw = create_attributes(...
    {'time','range'},...
    'Raw attenuated backscatter coefficient',...
    {'sr-1 m-1','sr<sup>-1</sup> m<sup>-1</sup>'},...
    C.missing_value,...
    [],...
    {[1e-7 1e-4],'logarithmic'});
% beta_error0
att1.beta_error0 = create_attributes(...
    {'time','range'},...
    'Fractional error in beta', ...
    {'',''}, ...
    C.missing_value, ...
    ['Fractional error estimate' ...
    ' applies to both backscatter and signal. Calculated'...
    ' from uncorrected signal.'],...
    {[.001,1],'logarithmic'});
% beta_error
att1.beta_error = create_attributes(...
    {'time','range'},...
    'Fractional error in beta', ...
    {'',''}, ...
    C.missing_value, ...
    ['Fractional error estimate' ...
    ' applies to both backscatter and signal. Calculated'...
    ' from corrected signal.'],...
    {[.001,1],'logarithmic'});
% v
att1.v = create_attributes(...
    {'time','range'},...
    'Radial velocity (positive away from lidar)', ...
    {'m s-1','m sr<sup>-1</sup>'}, ...
    C.missing_value, ...
    ['Background noise filtered with SNR threshold of ' ...
    num2str(data1.noise_threshold) '.'], ...
    {[-2 2],'linear'});
% beta
att1.beta = att1.beta_raw;
att1.beta.long_name = 'Attenuated backscatter coefficient';
att1.beta.comments = ['Background noise filtered with SNR threshold of ' ...
    num2str(data1.noise_threshold) '.'];
% divergence
att1.divergence = create_attributes(...
    {},...
    'Lidar laser beam divergence', ...
    'mrad');
% num_pulses_m2
att1.num_pulses_m2 = create_attributes(...
    {},...
    'Number of pulses per ray in mode 2', ...
    'unitless');
% noise threshold
att1.noise_threshold = create_attributes(...
    {},...
    'noise threshold, in arbitrary units, used to remove background noise',...
    '');
% beam energy
att1.beam_energy = create_attributes(...
    {},...
    'Laser energy', ...
    'J');
% num_lags
att1.num_lags = create_attributes(...
    {},...
    ['Number of lags used in evaluating the complex' ...
    ' autocorrelation function'], ...
    'unitless');
% lens diameter
att1.lens_diameter = create_attributes(...
    {},...
    'diameter of lens', ...
    'm');
% wavelength
att1.wavelength = create_attributes(...
    {},...
    'laser wavelength', ...
    'm');
% prf
att1.prf = create_attributes(...
    {},...
    'Pulse repetition frequency', ...
    'Hz');
% pulse length
att1.pulse_length = create_attributes(...
    {},...
    'Pulse length', ...
    's');
% bandwidth
att1.bandwidth = create_attributes(...
    {},...
    'Bandwidth', ...
    'Hz');

% Create global attributs
att1.global.Conventions = 'CF-1.0';
att1.global.system = C.system;
att1.global.location = C.location;
att1.global.source = C.source;
att1.global.institution = C.institution;
att1.global.title = C.title;
thedate = num2str(DATE);
att1.global.day   = int16(str2double(thedate(7:8)));
att1.global.month = int16(str2double(thedate(5:6)));
att1.global.year  = int16(str2double(thedate(1:4)));
current_date = datestr(now);
current_date(current_date == '-') = ' ';
att1.global.history = [current_date ' - Created by ' C.user ];

% Order fields
data1 = orderfields(data1);
att1  = orderfields(att1);

% Create dimensiosn
dim1 = struct('time',length(data1.time),'range',length(data1.range));

end


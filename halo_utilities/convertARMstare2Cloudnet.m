function convertARMstare2Cloudnet(site,DATES)
%convertARMToCloudnet reads ARM files and writes them with Cloudnet naming
  % scheme as new *.nc files.
%
% Usage:
% convertARMstare2Cloudnet(site,DATES)
%
% Inputs:
% - site       String, site name, e.g. site = 'kuopio'
% - DATES      Scalar, or vector, e.g. DATES = 20170630
%              or DATES = [20170601 20170630]
%
% Created 2017-10-29
% Antti Manninen
% University of Helsinki, Finland
% antti.j.manninen(at)helsinki.fi

% Check inputs
if nargin < 2
    error('''site'' and ''DATES'' are required inputs!')
end
if ~ischar(site)
    error('The first input ''site'' must be a string.')
end
if length(DATES)>2
    error('''DATES'' can have max. length of 2.')
elseif length(DATES)==1
    DATEstart = DATES; DATEend = DATES;
elseif ~isnumeric(DATES) || (length(num2str(DATES(1)))~=8 && ...
        length(num2str(DATES(2)))~=8)
    error(['The value(s) in the second input ''DATES'' must be' ...
        ' numerical date(s) in YYYYMMDD format.'])
else
    DATEstart = DATES(1); DATEend = DATES(2);
end

for DATEi = datenum(num2str(DATEstart),'yyyymmdd'):...
        datenum(num2str(DATEend),'yyyymmdd')
    
    % get date as string
    thedate = datestr(DATEi,'yyyymmdd');
    DATE = str2double(thedate);
    
    % Get site specific parameters
    C = getconfig(site,DATE);
    
    % Get file list
    [dir_to_folder_in,halo_files] = getHALOfileList(site,DATE,'corrected','stare');
    [dir_to_folder_out,~] = getHALOfileList(site,DATE,'calibrated','co');
    
    % Check path to write out
    status = checkHALOpath(site,DATE,'calibrated','co');
    if isempty(status)
        fprintf('Can''t write %s - %s.',num2str(DATE),site);
        continue;
    end
    
    % Set flag
    first_file = 1;
    
    % Initialize
    data.beta_error0 = [];
    data.beta_error  = [];
    data.v_error0    = [];
    data.v_error     = [];
    for i = 1:length(halo_files)
        % Load
        [data_tmp,att0,~] = load_nc_struct([dir_to_folder_in halo_files{i}]);
        if isempty(data_tmp)
            error('Can''t find file %s',[dir_to_folder halo_files{i}])
        end
        
        %%--- recalculate beta_error
        beta_error = (1/sqrt(C.num_pulses_m1)).*...
            (1+(1./abs(data_tmp.intensity-1)));
        beta_error0 = (1/sqrt(C.num_pulses_m1)).*...
            (1+(1./abs(data_tmp.intensity_uncorrected-1)));
        
        if first_file
            %%--- calculate radial velocity error due to random noise
            % Rye & Hardesty (1997); Pearson et al. (2009);
            % OConnor et al. (2010)
            [v_error, v_error_att] = calculateHALOveloError(...
                site,DATE,data_tmp.intensity);
            [v_error0, v_error_att0] = calculateHALOveloError(...
                site,DATE,data_tmp.intensity_uncorrected);
            
            % read beta, v, signal, time and range from input file
            data.beta_raw = data_tmp.attenuated_backscatter;
            if isempty(data.beta_raw); continue; end
            data.v_raw = data_tmp.radial_velocity;
            data.arm_qc_v_raw = data_tmp.qc_radial_velocity;
            data.signal = data_tmp.intensity;
            data.signal0 = data_tmp.intensity_uncorrected;
            data.time = data_tmp.time/3600; % from seconds to decimal hrs
            data.arm_qc_time = data_tmp.qc_time;
            data.range = data_tmp.range; % From metres to km
            
            %%--- read other variables ---%%
            data.latitude  = data_tmp.lat;
            data.longitude  = data_tmp.lon;
            if data.longitude < 0
                data.longitude = data.longitude + 360;
            end
            data.altitude = data_tmp.alt;
            data.azimuth = data_tmp.azimuth;
            data.elevation = data_tmp.elevation;
            data.num_pulses_m1 = C.num_pulses_m1;
            data.focus = C.focus;
            data.num_samples_gate = C.num_samples_gate;
            
            %%--- Create attributes ---%%
            % on the first file
            % radial velocity (raw)
            att.v_raw = create_attributes(...
                {'time','range'},...
                'Radial velocity (positive away from lidar)', ...
                {'m s-1','m sr<sup>-1</sup>'}, ...
                C.missing_value, ...
                'No noise removal.', ...
                {[-2 2],'linear'});
            att.v_raw.short_name = 'Doppler velocity';
            att.v_raw.resolution = ...
                str2double(att0.global.radial_velocity_resolution);
            att.v_raw.valid_min = att0.radial_velocity.valid_min;
            att.v_raw.valid_max = att0.radial_velocity.valid_max;
            % radial velocity (raw) ARM quality flags
            att.arm_qc_v_raw = create_attributes(...
                {'time','range'},...
                'ARM quality flags for Doppler velocity', ...
                'unitless', ...
                [], ...
                att0.qc_radial_velocity.description);
            % bkg corrected signal
            att.signal = create_attributes(...
                {'time','range'},...
                'Signal (raw)', ...
                'arbitrary units', ...
                C.missing_value, ...
                ['Background corrected signal (SNR + 1)' ...
                ' in arbitrary units.']);
            % original signal
            att.signal0 = create_attributes(...
                {'time','range'},...
                'Signal (raw)', ...
                'arbitrary units', ...
                C.missing_value, ...
                ['Original signal (SNR + 1) in arbitrary' ...
                ' units. No range correction or other' ...
                ' corrections applied.']);
            % time
            att.time = create_attributes(...
                {'time'},...
                'Decimal hours UTC', ...
                'Hours UTC');
            att.time.axis = 'T';
            % arm qc time
            att.arm_qc_time = att0.qc_time;
            att.arm_qc_time.dimensions = {'time'};
            % range
            att.range = create_attributes(...
                {'range'},...
                'Height above ground', ...
                'm',...
                [],...
                'This variable is range from lidar * sin(elevation)');
            att.range.axis = 'Z';
            % latitude
            att.latitude = create_attributes(...
                {},...
                'Latitude of lidar', ...
                'degrees_north');
            att.latitude.standard_name = 'latitude';
            % longitude
            att.longitude = create_attributes(...
                {},...
                'Longitude of lidar', ...
                'degrees_east');
            att.longitude.standard_name = 'longitude';
            % altitude
            att.altitude = create_attributes(...
                {},...
                'Height of instrument above mean sea level', ...
                'm');
            % azimuth
            att.azimuth = create_attributes(...
                {'time'},...
                'Azimuth from North', ...
                'degrees');
            % elevation
            att.elevation = create_attributes(...
                {'time'},...
                'Elevation from horizontal', ...
                'degrees');
            % num_pulses_m1
            att.num_pulses_m1 = create_attributes(...
                {},...
                'Number of pulses per ray in mode 1', ...
                'unitless');
            % focus
            att.focus = create_attributes(...
                {},...
                'Focus range', ...
                'm');
            % num_samples_gate
            att.num_samples_gate = create_attributes(...
                {},...
                'Number of samples (points) per gate', ...
                'unitless');
            % beta_raw
            att.beta_raw = create_attributes(...
                {'time','range'},...
                'Raw attenuated backscatter coefficient',...
                {'sr-1 m-1','sr<sup>-1</sup> m<sup>-1</sup>'},...
                C.missing_value,...
                [],...
                {[1e-7 1e-4],'logarithmic'});
            % beta_error0
            att.beta_error0 = create_attributes(...
                {'time','range'},...
                'Fractional error in beta', ...
                {'',''}, ...
                C.missing_value, ...
                ['Fractional standard deviation (error estimate)' ...
                ' applies to both backscatter and signal. Calculated'...
                ' from uncorrected signal.'],...
                {[.001,1],'logarithmic'});
            % beta_error
            att.beta_error = create_attributes(...
                {'time','range'},...
                'Fractional error in beta', ...
                {'',''}, ...
                C.missing_value, ...
                ['Fractional standard deviation (error estimate)' ...
                ' applies to both backscatter and signal. Calculated'...
                ' from corrected signal.'],...
                {[.001,1],'logarithmic'});
            % v_error0
            att.v_error0 = v_error_att0;
            % v_error
            att.v_error = v_error_att;
            % set flag
            first_file = 0;
        else
            if isempty(data_tmp)
                continue
            end
            
            %%--- calculate radial velocity error due to random noise
            % Rye & Hardesty (1997); Pearson et al. (2009);
            % OConnor et al. (2010)
            v_error = calculateHALOveloError(...
                site,DATE,data_tmp.intensity);
            v_error0 = calculateHALOveloError(...
                site,DATE,data_tmp.intensity_uncorrected);
            
            % Collect variables
            data.beta_raw = ...
                [data.beta_raw; data_tmp.attenuated_backscatter];
            data.v_raw = ...
                [data.v_raw; data_tmp.radial_velocity];
            data.arm_qc_v_raw = ...
                [data.arm_qc_v_raw; data_tmp.qc_radial_velocity];
            data.signal = ...
                [data.signal; data_tmp.intensity];
            data.signal0 = ...
                [data.signal0; data_tmp.intensity_uncorrected];
            data.time = ...
                [data.time; data_tmp.time/3600];
            data.arm_qc_time = ...
                [data.arm_qc_time; data_tmp.qc_time];
            data.azimuth = ...
                [data.azimuth; data_tmp.azimuth];
            data.elevation = ...
                [data.elevation; data_tmp.elevation];
        end
        % Collect rest of the variables
        data.beta_error0 = [data.beta_error0; beta_error0];
        data.beta_error  = [data.beta_error; beta_error];
        data.v_error0    = [data.v_error0; v_error0];
        data.v_error     = [data.v_error; v_error];
    end
    
    %-- Add remaining data fields --%
    data.v = data.v_raw;
    data.v(data.signal < C.snr_threshold_for_vertical) = nan;
    data.beta = data.beta_raw;
    data.beta(data.signal < C.snr_threshold_for_vertical) = nan;
    data.divergence = C.divergence;
    data.num_pulses_m2 = C.num_pulses_m2;
    data.num_lags = C.num_lags;
    data.lens_diameter = C.lens_diameter;
    data.wavelength = C.wavelength;
    data.prf = C.prf;
    data.pulse_length= C.pulse_length;
    data.bandwidth = C.bandwidth;
    % clean lowest most range bins
    data.v(:,1:3) = nan;
    data.v_raw(:,1:3) = nan;
    data.beta(:,1:3) = nan;
    data.beta_raw(:,1:3) = nan;
    data.signal(:,1:3) = nan;
    
    %-- Add remaining attributes --%%
    % v
    att.v = create_attributes(...
        {'time','range'},...
        'Radial velocity (positive away from lidar)', ...
        {'m s-1','m sr<sup>-1</sup>'}, ...
        C.missing_value, ...
        ['Background noise filtered with SNR threshold of ' ...
        num2str(C.snr_threshold_for_vertical) '.'], ...
        {[-2 2],'linear'});
    % beta
    att.beta = att.beta_raw;
    att.beta.long_name = 'Attenuated backscatter coefficient';
    % divergence
    att.divergence = create_attributes(...
        {},...
        'Lidar laser beam divergence', ...
        'mrad');
    % num_pulses_m2
    att.num_pulses_m2 = create_attributes(...
        {},...
        'Number of pulses per ray in mode 2', ...
        'unitless');
    % num_lags
    att.num_lags = create_attributes(...
        {},...
        ['Number of lags used in evaluating the complex' ...
        ' autocorrelation function'], ...
        'unitless');
    % lens diameter
    att.lens_diameter = create_attributes(...
        {},...
        'diameter of lens', ...
        'm');
    % wavelength
    att.wavelength = create_attributes(...
        {},...
        'laser wavelength', ...
        'm');
    % prf
    att.prf = create_attributes(...
        {},...
        'Pulse repetition frequency', ...
        'Hz');
    % pulse length
    att.pulse_length = create_attributes(...
        {},...
        'Pulse length', ...
        's');
    % bandwidth
    att.bandwidth = create_attributes(...
        {},...
        'Bandwidth', ...
        'Hz');
    
    % Create global attributs
    att.global.Conventions = 'CF-1.0';
    att.global.system = C.system;
    att.global.location = C.location;
    att.global.source = C.source;
    att.global.institution = C.institution;
    att.global.title = C.title;
    att.global.day   = str2double(thedate(7:8));
    att.global.month = str2double(thedate(5:6));
    att.global.year  = str2double(thedate(1:4));
    current_date = datestr(now);
    current_date(current_date == '-') = ' ';
    att.global.history = [current_date ' - Created by ' C.user ];
    
    % Create dimensiosn
    dim = struct('time',length(data.time),'range',length(data.range));
    
    % Order fields
    data = orderfields(data);
    att  = orderfields(att);
    
    % Write into new netcdf
    write_nc_struct(fullfile([dir_to_folder_out '/' thedate ...
        '_' site '_halo-doppler-lidar_co.nc']), dim, data, att)
    
end

